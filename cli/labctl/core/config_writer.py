"""
Configuration writer for saving structured YAML configurations
"""

from pathlib import Path
from typing import Dict, Any, Optional
import yaml
from rich.console import Console

console = Console()


def save_config_to_yaml(config_data: dict, config_path: Path) -> None:
    """
    Save configuration data to YAML file in a human-friendly format
    
    Args:
        config_data: Configuration dictionary to save
        config_path: Path where to save the configuration
    """
    # Ensure directory exists
    config_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Remove env_vars from config before saving (they go to .env)
    config_to_save = {k: v for k, v in config_data.items() if k != 'env_vars'}
    
    # Process services to ensure proper structure
    if 'services' in config_to_save:
        services = config_to_save['services']
        processed_services = {}
        
        for service_id, service_config in services.items():
            if hasattr(service_config, 'dict'):
                # Pydantic model - convert to dict
                processed_services[service_id] = service_config.dict(exclude_unset=True)
            elif isinstance(service_config, dict):
                # Already a dict
                processed_services[service_id] = service_config
            else:
                # Convert to dict representation
                processed_services[service_id] = dict(service_config) if service_config else {}
        
        config_to_save['services'] = processed_services
    
    # Write YAML with nice formatting and comments
    with open(config_path, 'w') as f:
        # Write header comment
        f.write("# Home Lab Configuration v2\n")
        f.write("# Generated by labctl - Enterprise Home Lab CLI\n")
        f.write("# Edit this file to modify your infrastructure configuration\n\n")
        
        # Write structured YAML
        yaml.dump(
            config_to_save,
            f,
            default_flow_style=False,
            indent=2,
            sort_keys=False,
            allow_unicode=True
        )


def load_config_from_yaml(config_path: Path) -> Dict[str, Any]:
    """
    Load configuration from YAML file
    
    Args:
        config_path: Path to the configuration file
        
    Returns:
        Configuration dictionary
    """
    if not config_path.exists():
        raise FileNotFoundError(f"Configuration file not found: {config_path}")
    
    with open(config_path, 'r') as f:
        return yaml.safe_load(f) or {}


def save_labconfig_to_yaml(lab_config, config_path: Path) -> None:
    """
    Save LabConfig instance to YAML file with structured output
    
    Args:
        lab_config: LabConfig instance to save
        config_path: Path where to save the configuration
    """
    # Convert LabConfig to dict
    config_dict = lab_config.dict(exclude_unset=True)
    
    # Handle enum serialization
    if 'profile' in config_dict and hasattr(config_dict['profile'], 'value'):
        config_dict['profile'] = config_dict['profile'].value
    
    save_config_to_yaml(config_dict, config_path)


def save_structured_config(
    version: int,
    profile: str,
    core: Dict[str, Any],
    services: Dict[str, Dict[str, Any]],
    custom_env: Optional[Dict[str, Dict[str, str]]] = None,
    config_path: Path = Path("config/config.yaml")
) -> None:
    """
    Save structured configuration with proper organization
    
    Args:
        version: Configuration version (should be 2)
        profile: Deployment profile (dev/prod)
        core: Core configuration (domain, email, etc.)
        services: Service configurations
        custom_env: Custom environment variables per service
        config_path: Path to save configuration
    """
    config_data = {
        'version': version,
        'profile': profile,
        'core': core,
        'services': services
    }
    
    if custom_env:
        config_data['custom_env'] = custom_env
    
    save_config_to_yaml(config_data, config_path)


def create_example_config() -> Dict[str, Any]:
    """
    Create an example configuration for documentation
    
    Returns:
        Example configuration dictionary
    """
    return {
        'version': 2,
        'profile': 'prod',
        'core': {
            'domain': 'example.com',
            'email': 'admin@example.com'
        },
        'services': {
            'traefik': {
                'enabled': True,
                'domain': 'example.com',
                'email': 'admin@example.com',
                'acme_environment': 'production',
                'wildcard_enabled': True,
                'dashboard_enabled': True
            },
            'postgresql': {
                'enabled': True,
                'port': 5432,
                'superuser': 'postgres',
                'backup_enabled': True
            },
            'redis': {
                'enabled': True,
                'port': 6379,
                'persistence': 'rdb'
            },
            'monitoring': {
                'enabled': True,
                'prometheus_retention': '30d',
                'external_port': 9090,
                'grafana_admin_user': 'admin'
            },
            'nextcloud': {
                'enabled': True,
                'admin_user': 'admin',
                'http_port': 8081,
                'domain': 'nextcloud.example.com'
            }
        },
        'custom_env': {
            'nextcloud': {
                'DEBUG': 'false',
                'UPLOAD_MAX_FILESIZE': '2G'
            }
        }
    }


def validate_config_format(config_data: dict) -> bool:
    """
    Validate that configuration has required structure
    
    Args:
        config_data: Configuration dictionary to validate
        
    Returns:
        True if valid format
    """
    required_fields = ['version', 'profile', 'core', 'services']
    
    for field in required_fields:
        if field not in config_data:
            console.print(f"[red]Missing required field: {field}[/red]")
            return False
    
    # Check version
    if config_data.get('version') != 2:
        console.print(f"[red]Unsupported config version: {config_data.get('version')}[/red]")
        return False
    
    # Check profile
    valid_profiles = ['dev', 'prod', 'development', 'production']
    if config_data.get('profile') not in valid_profiles:
        console.print(f"[red]Invalid profile: {config_data.get('profile')}. Must be one of {valid_profiles}[/red]")
        return False
    
    # Check core fields
    core = config_data.get('core', {})
    if not core.get('domain') or not core.get('email'):
        console.print("[red]Core section missing domain or email[/red]")
        return False
    
    # Validate services section
    services = config_data.get('services', {})
    if not isinstance(services, dict):
        console.print("[red]Services section must be a dictionary[/red]")
        return False
    
    # Check that enabled services have required fields
    for service_id, service_config in services.items():
        if not isinstance(service_config, dict):
            console.print(f"[red]Service {service_id} configuration must be a dictionary[/red]")
            return False
        
        if 'enabled' not in service_config:
            console.print(f"[yellow]Warning: Service {service_id} missing 'enabled' field[/yellow]")
    
    return True
