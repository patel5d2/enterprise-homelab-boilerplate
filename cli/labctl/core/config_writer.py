"""
Configuration writer for saving structured YAML configurations
"""

from pathlib import Path
from typing import Any, Dict, Optional

import yaml
from rich.console import Console

console = Console()


def save_config_to_yaml(config_data: dict, config_path: Path) -> None:
    """
    Save configuration data to YAML file in a human-friendly format

    Args:
        config_data: Configuration dictionary to save
        config_path: Path where to save the configuration
    """
    # Ensure directory exists
    config_path.parent.mkdir(parents=True, exist_ok=True)

    # Remove env_vars from config before saving (they go to .env)
    config_to_save = {k: v for k, v in config_data.items() if k != "env_vars"}

    # Process services to ensure proper structure
    if "services" in config_to_save:
        services = config_to_save["services"]
        processed_services = {}

        for service_id, service_config in services.items():
            if hasattr(service_config, "dict"):
                # Pydantic model - convert to dict
                processed_services[service_id] = service_config.dict(exclude_unset=True)
            elif isinstance(service_config, dict):
                # Already a dict
                processed_services[service_id] = service_config
            else:
                # Convert to dict representation
                processed_services[service_id] = (
                    dict(service_config) if service_config else {}
                )

        config_to_save["services"] = processed_services

    # Write YAML with nice formatting and comments
    with open(config_path, "w") as f:
        # Write header comment
        f.write("# Home Lab Configuration v2\n")
        f.write("# Generated by labctl - Enterprise Home Lab CLI\n")
        f.write("# Edit this file to modify your infrastructure configuration\n\n")

        # Write structured YAML
        yaml.dump(
            config_to_save,
            f,
            default_flow_style=False,
            indent=2,
            sort_keys=False,
            allow_unicode=True,
        )


def load_config_from_yaml(config_path: Path) -> Dict[str, Any]:
    """
    Load configuration from YAML file

    Args:
        config_path: Path to the configuration file

    Returns:
        Configuration dictionary
    """
    if not config_path.exists():
        raise FileNotFoundError(f"Configuration file not found: {config_path}")

    with open(config_path, "r") as f:
        return yaml.safe_load(f) or {}


def save_labconfig_to_yaml(lab_config, config_path: Path) -> None:
    """
    Save LabConfig instance to YAML file with structured output

    Args:
        lab_config: LabConfig instance to save
        config_path: Path where to save the configuration
    """
    # Convert LabConfig to dict
    config_dict = lab_config.dict(exclude_unset=True)

    # Handle enum serialization
    if "profile" in config_dict and hasattr(config_dict["profile"], "value"):
        config_dict["profile"] = config_dict["profile"].value

    save_config_to_yaml(config_dict, config_path)


def save_structured_config(
    version: int,
    profile: str,
    core: Dict[str, Any],
    services: Dict[str, Dict[str, Any]],
    custom_env: Optional[Dict[str, Dict[str, str]]] = None,
    config_path: Path = Path("config/config.yaml"),
) -> None:
    """
    Save structured configuration with proper organization

    Args:
        version: Configuration version (should be 2)
        profile: Deployment profile (dev/prod)
        core: Core configuration (domain, email, etc.)
        services: Service configurations
        custom_env: Custom environment variables per service
        config_path: Path to save configuration
    """
    config_data = {
        "version": version,
        "profile": profile,
        "core": core,
        "services": services,
    }

    if custom_env:
        config_data["custom_env"] = custom_env

    save_config_to_yaml(config_data, config_path)


def create_example_config() -> Dict[str, Any]:
    """
    Create an example configuration for documentation

    Returns:
        Example configuration dictionary
    """
    return {
        "version": 2,
        "profile": "prod",
        "core": {"domain": "example.com", "email": "admin@example.com"},
        "services": {
            "traefik": {
                "enabled": True,
                "domain": "example.com",
                "email": "admin@example.com",
                "acme_environment": "production",
                "wildcard_enabled": True,
                "dashboard_enabled": True,
            },
            "postgresql": {
                "enabled": True,
                "port": 5432,
                "superuser": "postgres",
                "backup_enabled": True,
            },
            "redis": {"enabled": True, "port": 6379, "persistence": "rdb"},
            "monitoring": {
                "enabled": True,
                "prometheus_retention": "30d",
                "external_port": 9090,
                "grafana_admin_user": "admin",
            },
            "nextcloud": {
                "enabled": True,
                "admin_user": "admin",
                "http_port": 8081,
                "domain": "nextcloud.example.com",
            },
        },
        "custom_env": {"nextcloud": {"DEBUG": "false", "UPLOAD_MAX_FILESIZE": "2G"}},
    }


def validate_config_format(config_data: dict) -> bool:
    """
    Validate that configuration has required structure

    Args:
        config_data: Configuration dictionary to validate

    Returns:
        True if valid format
    """
    required_fields = ["version", "profile", "core", "services"]

    for field in required_fields:
        if field not in config_data:
            console.print(f"[red]Missing required field: {field}[/red]")
            return False

    # Check version
    if config_data.get("version") != 2:
        console.print(
            f"[red]Unsupported config version: {config_data.get('version')}[/red]"
        )
        return False

    # Check profile
    valid_profiles = ["dev", "prod", "development", "production"]
    if config_data.get("profile") not in valid_profiles:
        console.print(
            f"[red]Invalid profile: {config_data.get('profile')}. Must be one of {valid_profiles}[/red]"
        )
        return False

    # Check core fields
    core = config_data.get("core", {})
    if not core.get("domain") or not core.get("email"):
        console.print("[red]Core section missing domain or email[/red]")
        return False

    # Validate services section
    services = config_data.get("services", {})
    if not isinstance(services, dict):
        console.print("[red]Services section must be a dictionary[/red]")
        return False

    # Check that enabled services have required fields
    for service_id, service_config in services.items():
        if not isinstance(service_config, dict):
            console.print(
                f"[red]Service {service_id} configuration must be a dictionary[/red]"
            )
            return False

        if "enabled" not in service_config:
            console.print(
                f"[yellow]Warning: Service {service_id} missing 'enabled' field[/yellow]"
            )

    return True
